**Для выхода '#'. 
Закомментил задержу в 1 секунду на чтение получателем с кольцевого буфера, а у отправителя вывод в stdout (просто буква R, которая означает - прочитал 1 char). С ними легко тестить кольцевой буфер. Пытаемся его переполнить и смотрим на stdout. Буфер заполняется, и если все-таки заполнится, то отправитель сидит и ждет, пока его сообщения не будут прочтены (для этого 1 секунда и стоит).**  

**Вообще крутые задачи на IPC, я бы еще поделал, мне понравилось.**   
 
35. Кольцевая очередь в разделяемой памяти   

═══════════ Реализуйте кольцевую очередь фиксированной длины в разделяемой памяти. Программа - производитель читает с клавиатуры и помещает прочитанный текст в виде записи в конец очереди. Потребитель берет записи из начала очереди. При обнаружении некоторого условия окончания, производитель должен перед выходом поместить в очередь запись-ограничитель. Когда потребитель получит такую запись, он также завершится.
  
Советы:    

Очередь должна представлять собой массив записей. Таким образом, размер каждой записи не может превосходить фиксированную максимальную величину.  
добавление записи в хвост очереди (псевдокод)  
╥        tail <- tail +1  
╥        if tail = QUE_SIZE, tail <- 0  
╥        if tail = head, queue full condition  
╥        else queue[tail] <- item  
  
получение записи из начала очереди (псевдокод)  
╥        if tail = head, queue empty condition  
╥        head <- head +1  
╥        if head = QUE_SIZE, head <- 0  
╥        else item <- queue[head]  
