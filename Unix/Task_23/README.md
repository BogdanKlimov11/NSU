# 23. Кольцевая очередь в разделяемой памяти   

**Для выхода '#'. Закомментил задержу в 1 секунду на чтение получателем с кольцевого буфера, а у отправителя вывод в stdout (просто буква R, которая означает - прочитал 1 char). С ними легко тестить кольцевой буфер. Пытаемся его переполнить и смотрим на stdout. Буфер заполняется, и если все-таки заполнится, то отправитель сидит и ждет, пока его сообщения не будут прочтены (для этого 1 секунда и стоит).**  

**Вообще крутые задачи на IPC, я бы еще поделал, мне понравилось.**  

Реализуйте кольцевую очередь фиксированной длины в разделяемой памяти. Программа - производитель читает с клавиатуры и помещает прочитанный текст в виде записи в конец очереди. Потребитель берет записи из начала очереди. При обнаружении некоторого условия окончания, производитель должен перед выходом поместить в очередь запись-ограничитель. Когда потребитель получит такую запись, он также завершится.
  
Советы:    

> Очередь должна представлять собой массив записей. Таким образом, размер каждой записи не может превосходить фиксированную максимальную величину.  

добавление записи в хвост очереди (псевдокод)  

```c
tail <- tail +1  
if tail = QUE_SIZE, tail <- 0  
if tail = head, queue full condition  
else queue[tail] <- item
```

получение записи из начала очереди (псевдокод)  

```c
if tail = head, queue empty condition  
head <- head + 1  
if head = QUE_SIZE, head <- 0  
else item <- queue[head]  
```
