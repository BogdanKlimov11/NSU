import numpy as np
import matplotlib.pyplot as plt

# Определение класса для разложения сигнала в ряд Фурье
class FourierSeries:
    # Инициализация класса с параметрами периода и количества членов ряда
    def __init__(self, period, n_terms):
        self.T = period # Период сигнала (время одного полного цикла)
        self.N = n_terms # Количество членов ряда Фурье для аппроксимации
        self.w = 2 * np.pi / period # Угловая частота (ω = 2π/T), определяет частоту колебаний
    
    # Метод для генерации прямоугольного импульса
    def rectangular_pulse(self, t, width, amplitude):
        """Генерация прямоугольного импульса с заданной шириной и амплитудой"""
        # Возвращает массив, где значения равны amplitude, если время внутри импульса, иначе 0
        return amplitude * (np.abs(t % self.T) < width/2)
        # np.abs(t % self.T) вычисляет позицию внутри периода, сравнение с width/2 определяет границы импульса
    
    # Метод для генерации пилообразного сигнала
    def sawtooth_pulse(self, t, amplitude):
        """Генерация пилообразного сигнала с заданной амплитудой"""
        # Вычисляем позицию внутри периода (0 до 1)
        phase = (t % self.T) / self.T
        # Линейно возрастающий сигнал от -amplitude до +amplitude
        return amplitude * (2 * phase - 1)
    
    # Метод для генерации треугольного сигнала
    def triangular_pulse(self, t, amplitude):
        """Генерация треугольного сигнала с заданной амплитудой"""
        # Вычисляем позицию внутри периода (0 до 1)
        phase = (t % self.T) / self.T
        # Треугольный сигнал: рост до 0.5, затем спад
        return amplitude * (2 * np.abs(2 * phase - 1) - 1)
    
    # Метод для генерации синусоидального сигнала
    def sine_wave(self, t, amplitude):
        """Генерация синусоидального сигнала с заданной амплитудой"""
        # Частота = 1/период, умножаем на 2π для радиан
        return amplitude * np.sin(2 * np.pi * t / self.T)
    
    # Метод для генерации косинусоидального сигнала
    def cosine_wave(self, t, amplitude):
        """Генерация косинусоидального сигнала с заданной амплитудой"""
        # Частота = 1/период, умножаем на 2π для радиан
        return amplitude * np.cos(2 * np.pi * t / self.T)
    
    # Метод для вычисления коэффициентов Фурье (a0, an, bn)
    def get_coefficients(self, func, width, amplitude):
        """Вычисление коэффициентов Фурье для заданной функции"""
        t = np.linspace(0, self.T, 1000) # Создание массива времени от 0 до T с 1000 точками для интегрирования
        
        # Вычисление постоянной составляющей a0 (среднее значение сигнала)
        a0 = (2/self.T) * np.trapz(func(t, width, amplitude), t)
        # np.trapz выполняет численное интегрирование по методу трапеций
        
        # Инициализация списков для коэффициентов an (косинусные) и bn (синусные)
        an = []
        bn = []
        # Цикл по номерам гармоник от 1 до N
        for n in range(1, self.N + 1):
            # Вычисление an для текущей гармоники (проекция на косинус)
            an_n = (2/self.T) * np.trapz(func(t, width, amplitude) * np.cos(n * self.w * t), t)
            # Вычисление bn для текущей гармоники (проекция на синус)
            bn_n = (2/self.T) * np.trapz(func(t, width, amplitude) * np.sin(n * self.w * t), t)
            an.append(an_n) # Добавление an в список
            bn.append(bn_n) # Добавление bn в список
            
        # Возвращаем a0 и массивы an, bn (преобразуем списки в numpy массивы)
        return a0, np.array(an), np.array(bn)
    
    # Метод для аппроксимации сигнала с использованием коэффициентов Фурье
    def approximate(self, t, a0, an, bn):
        """Аппроксимация сигнала с помощью ряда Фурье"""
        result = a0/2 * np.ones_like(t) # Начальное значение — постоянная составляющая (a0/2)
        # Цикл по гармоникам для добавления косинусных и синусных членов
        for n in range(1, self.N + 1):
            result += (an[n-1] * np.cos(n * self.w * t) + bn[n-1] * np.sin(n * self.w * t))
            # n-1 используется, так как индексы массивов начинаются с 0
        return result # Возвращаем аппроксимированный сигнал

# Определение параметров сигнала
T = 1.0 # Период сигнала в секундах
width = 0.5 # Ширина прямоугольного импульса (доля периода)
A = 1.0 # Амплитуда сигнала
N = 10 # Количество членов ряда Фурье для аппроксимации

# Создание объекта класса FourierSeries с заданными параметрами
fs = FourierSeries(T, N)

# Создание массива времени для двух периодов (от 0 до 2T) с 1000 точками
t = np.linspace(0, 2*T, 1000)

# Генерация исходного прямоугольного сигнала
x_t = fs.rectangular_pulse(t, width, A)

# Вычисление коэффициентов Фурье и аппроксимации сигнала
a0, an, bn = fs.get_coefficients(fs.rectangular_pulse, width, A) # Получаем a0, an, bn
x_t_approx = fs.approximate(t, a0, an, bn) # Вычисляем аппроксимированный сигнал x*(t)

# Вычисление погрешности аппроксимации (разница между исходным и аппроксимированным сигналом)
error = x_t - x_t_approx

# Создание фигуры для графиков размером 12x8 дюймов
plt.figure(figsize=(12, 8))

# Построение первого графика: исходный сигнал и его аппроксимация
plt.subplot(2, 1, 1) # Первый подграфик в сетке 2 строки x 1 столбец
plt.plot(t, x_t, 'b-', label='x(t)') # Исходный сигнал — синяя сплошная линия
plt.plot(t, x_t_approx, 'r--', label=f'x*(t), N={N}') # Аппроксимация — красный пунктир
plt.grid(True) # Добавление сетки
plt.legend() # Отображение легенды с подписями
plt.title('Исходный сигнал и аппроксимация') # Заголовок графика

# Построение второго графика: погрешность аппроксимации
plt.subplot(2, 1, 2) # Второй подграфик в той же сетке
plt.plot(t, error, 'g-', label='Погрешность') # Погрешность — зелёная сплошная линия
plt.grid(True) # Добавление сетки
plt.legend() # Отображение легенды
plt.title('Погрешность приближения') # Заголовок графика

plt.tight_layout() # Автоматическая регулировка расстояний между подграфиками

# Генерация косинусоидального сигнала
f = 100 # Частота косинуса в герцах (100 Гц)
w = 2 * np.pi * f # Угловая частота косинуса (ω = 2πf)
t_cos = np.linspace(0, 1/f * 2, 1000) # Временной массив для двух периодов косинуса
x_cos = A * np.cos(w * t_cos) # Косинусоидальный сигнал с амплитудой A

# Вычисление спектра косинусоиды с помощью быстрого преобразования Фурье (FFT)
fft_result = np.fft.fft(x_cos) # Применение FFT к косинусу
freq = np.fft.fftfreq(len(t_cos), t_cos[1] - t_cos[0]) # Вычисление частотного массива
fft_magnitude = np.abs(fft_result) # Амплитуда спектра (модуль комплексных чисел)

# Построение графика спектра косинусоиды
plt.figure(figsize=(12, 4)) # Новая фигура размером 12x4 дюйма
plt.plot(freq[:len(freq)//2], fft_magnitude[:len(freq)//2], 'b-') # Спектр для положительных частот
plt.title('Спектр косинусоидального сигнала') # Заголовок графика
plt.xlabel('Частота (Гц)') # Подпись оси X
plt.ylabel('Амплитуда') # Подпись оси Y
plt.grid(True) # Добавление сетки

# Вычисление спектра прямоугольного сигнала через FFT
fft_rect = np.fft.fft(x_t) # Применение FFT к прямоугольному сигналу
freq_rect = np.fft.fftfreq(len(t), t[1] - t[0]) # Частотный массив для прямоугольного сигнала
fft_rect_magnitude = np.abs(fft_rect) # Амплитуда спектра

# Построение графика спектра прямоугольного сигнала
plt.figure(figsize=(12, 4)) # Новая фигура размером 12x4 дюйма
plt.plot(freq_rect[:len(freq_rect)//2], fft_rect_magnitude[:len(freq_rect)//2], 'b-') # Спектр
plt.title('Спектр прямоугольного сигнала (FFT)') # Заголовок графика
plt.xlabel('Частота (Гц)') # Подпись оси X
plt.ylabel('Амплитуда') # Подпись оси Y
plt.grid(True) # Добавление сетки

# Добавление шума к прямоугольному сигналу
noise = np.random.normal(0, 0.1, len(t)) # Генерация белого шума (ср. значение 0, дисперсия 0.1)
x_t_noisy = x_t + noise # Добавление шума к исходному сигналу
fft_noisy = np.fft.fft(x_t_noisy) # Вычисление FFT для зашумленного сигнала
fft_noisy_magnitude = np.abs(fft_noisy) # Амплитуда спектра зашумленного сигнала

# Построение графиков для зашумленного сигнала
plt.figure(figsize=(12, 8)) # Новая фигура размером 12x8 дюймов
plt.subplot(2, 1, 1) # Первый подграфик
plt.plot(t, x_t_noisy, 'b-') # График зашумленного сигнала во временной области
plt.title('Сигнал с шумом') # Заголовок
plt.grid(True) # Сетка

plt.subplot(2, 1, 2) # Второй подграфик
plt.plot(freq_rect[:len(freq_rect)//2], fft_noisy_magnitude[:len(freq_rect)//2], 'b-')  # Спектр
plt.title('Спектр сигнала с шумом') # Заголовок
plt.xlabel('Частота (Гц)') # Подпись оси X
plt.ylabel('Амплитуда') # Подпись оси Y
plt.grid(True) # Сетка

plt.tight_layout() # Регулировка расстояний между подграфиками
plt.show() # Отображение всех графиков

# Вывод пояснения результатов для влияния шума на спектр сигнала
print("""
При добавлении шума к сигналу в спектре появляются дополнительные частотные компоненты.
Это происходит потому что шум имеет случайную природу и содержит широкий спектр частот.
Основная форма спектра сохраняется, но появляется "шумовой фон" на всех частотах.
Амплитуда шумовых компонент зависит от уровня добавленного шума.
""")
