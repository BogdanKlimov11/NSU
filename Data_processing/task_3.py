import numpy as np
import matplotlib.pyplot as plt
from scipy import signal

# Общие параметры для всей программы
fs = 2000 # Частота дискретизации в герцах (количество отсчётов в секунду), выбрана больше 2*450 Гц для точности
t = np.linspace(0, 1, fs, endpoint=False) # Создаём временной массив от 0 до 1 с с шагом 1/fs, без конечной точки
x = np.cos(2 * np.pi * 50 * t) + np.cos(2 * np.pi * 150 * t) + np.cos(2 * np.pi * 450 * t) # Исходный сигнал: сумма косинусов с частотами 50, 150 и 450 Гц

# 1. Вычисление и построение спектра исходного сигнала
fft_result = np.fft.fft(x) # Вычисляем спектр сигнала с помощью быстрого преобразования Фурье (FFT)
freq = np.fft.fftfreq(len(t), 1/fs) # Создаём массив частот в герцах на основе длины сигнала и шага времени
fft_magnitude = np.abs(fft_result) # Вычисляем амплитуду спектра, беря модуль комплексных чисел из FFT

plt.figure(figsize=(12, 4)) # Создаём новую фигуру для графика размером 12x4 дюйма
plt.plot(freq[:len(freq)//2], fft_magnitude[:len(freq)//2], 'b-') # Строим спектр для положительных частот (синяя линия)
plt.title('Спектр исходного сигнала (50, 150, 450 Гц)')  # Устанавливаем заголовок графика
plt.xlabel('Частота (Гц)') # Подписываем ось X как "Частота (Гц)"
plt.ylabel('Амплитуда') # Подписываем ось Y как "Амплитуда"
plt.grid(True) # Добавляем сетку на график для удобства чтения

# 2. Реализация фильтра Баттерворта нижних частот (ФНЧ) 2-го порядка
fc = 100 # Частота среза фильтра в герцах, выбрана в диапазоне 70–120 Гц для подавления 150 и 450 Гц
w_c = 2 * np.pi * fc # Вычисляем угловую частоту среза (ω_c = 2πf_c) в радианах/с
s = 1j * 2 * np.pi * freq # Создаём массив комплексных частот s = jω для вычисления передаточной функции
H_lp = 1 / (1 + s/w_c)**2 # Передаточная функция ФНЧ 2-го порядка по формуле 32: H(s) = 1 / (1 + s/ω_c)^2
x_filtered_lp = signal.lfilter([1], [1, 2*w_c, w_c**2], x) # Применяем фильтр во временной области с коэффициентами [числитель], [знаменатель]
fft_filtered_lp = np.fft.fft(x_filtered_lp) # Вычисляем спектр отфильтрованного сигнала с помощью FFT

plt.figure(figsize=(12, 8)) # Создаём фигуру размером 12x8 дюймов для двух подграфиков
plt.subplot(2, 1, 1) # Первый подграфик в сетке 2 строки x 1 столбец, позиция 1
plt.plot(t, x, 'b-', label='Исходный сигнал') # Строим исходный сигнал во временной области (синяя линия)
plt.plot(t, x_filtered_lp, 'r-', label='Отфильтрованный сигнал (ФНЧ 2-го порядка)') # Строим отфильтрованный сигнал (красная линия)
plt.title('Исходный и отфильтрованный сигнал') # Устанавливаем заголовок первого подграфика
plt.xlabel('Время (с)') # Подписываем ось X как "Время (с)"
plt.ylabel('Амплитуда') # Подписываем ось Y как "Амплитуда"
plt.legend() # Отображаем легенду с подписями линий
plt.grid(True) # Добавляем сетку

plt.subplot(2, 1, 2) # Второй подграфик, позиция 2
plt.plot(freq[:len(freq)//2], fft_magnitude[:len(freq)//2], 'b-', label='Исходный спектр') # Исходный спектр (синяя линия)
plt.plot(freq[:len(freq)//2], np.abs(fft_filtered_lp)[:len(freq)//2], 'r-', label='Отфильтрованный спектр') # Спектр отфильтрованного сигнала (красная линия)
plt.plot(freq[:len(freq)//2], np.abs(H_lp)[:len(freq)//2], 'g--', label='АЧХ фильтра') # Амплитудно-частотная характеристика фильтра (зелёный пунктир)
plt.title('Спектр сигнала и фильтра') # Устанавливаем заголовок второго подграфика
plt.xlabel('Частота (Гц)') # Подписываем ось X
plt.ylabel('Амплитуда') # Подписываем ось Y
plt.legend() # Отображаем легенду
plt.grid(True) # Добавляем сетку
plt.tight_layout() # Регулируем расстояние между подграфиками для аккуратного отображения

# 3. Сигнал только с частотами 50 и 450 Гц и сравнение с отфильтрованным
x_50_450 = np.cos(2 * np.pi * 50 * t) + np.cos(2 * np.pi * 450 * t) # Создаём сигнал с частотами 50 и 450 Гц (без 150 Гц)
fft_50_450 = np.fft.fft(x_50_450) # Вычисляем спектр этого сигнала
plt.figure(figsize=(12, 4)) # Создаём фигуру размером 12x4 дюйма
plt.plot(freq[:len(freq)//2], np.abs(fft_50_450)[:len(freq)//2], 'b-', label='Спектр (50 и 450 Гц)') # Спектр сигнала 50+450 Гц (синяя линия)
plt.plot(freq[:len(freq)//2], np.abs(fft_filtered_lp)[:len(freq)//2], 'r-', label='Отфильтрованный спектр (ФНЧ)') # Спектр отфильтрованного сигнала из пункта 2 (красная линия)
plt.title('Сравнение спектров (50+450 Гц и отфильтрованный)') # Устанавливаем заголовок графика
plt.xlabel('Частота (Гц)') # Подписываем ось X
plt.ylabel('Амплитуда') # Подписываем ось Y
plt.legend() # Отображаем легенду
plt.grid(True) # Добавляем сетку

# 4. Фильтр Баттерворта высоких частот (ФВЧ) 2-го порядка
H_hp = (s/w_c)**2 / (1 + s/w_c)**2 # Передаточная функция ФВЧ по формуле 35: H(s) = (s/ω_c)^2 / (1 + s/ω_c)^2
x_filtered_hp = signal.lfilter([1, 0, 0], [1, 2*w_c, w_c**2], x) # Применяем ФВЧ во временной области с коэффициентами
fft_filtered_hp = np.fft.fft(x_filtered_hp) # Вычисляем спектр отфильтрованного сигнала

plt.figure(figsize=(12, 8)) # Создаём фигуру размером 12x8 дюймов для двух подграфиков
plt.subplot(2, 1, 1) # Первый подграфик
plt.plot(t, x, 'b-', label='Исходный сигнал') # Исходный сигнал (синяя линия)
plt.plot(t, x_filtered_hp, 'r-', label='Отфильтрованный сигнал (ФВЧ)') # Отфильтрованный сигнал (красная линия)
plt.title('Исходный и отфильтрованный сигнал (ФВЧ)') # Заголовок первого подграфика
plt.xlabel('Время (с)') # Подпись оси X
plt.ylabel('Амплитуда') # Подпись оси Y
plt.legend() # Легенда
plt.grid(True) # Сетка

plt.subplot(2, 1, 2) # Второй подграфик
plt.plot(freq[:len(freq)//2], fft_magnitude[:len(freq)//2], 'b-', label='Исходный спектр') # Исходный спектр
plt.plot(freq[:len(freq)//2], np.abs(fft_filtered_hp)[:len(freq)//2], 'r-', label='Отфильтрованный спектр') # Спектр после ФВЧ
plt.plot(freq[:len(freq)//2], np.abs(H_hp)[:len(freq)//2], 'g--', label='АЧХ фильтра') # АЧХ фильтра ФВЧ
plt.title('Спектр сигнала и фильтра (ФВЧ)') # Заголовок второго подграфика
plt.xlabel('Частота (Гц)') # Подпись оси X
plt.ylabel('Амплитуда') # Подпись оси Y
plt.legend() # Легенда
plt.grid(True) # Сетка
plt.tight_layout() # Регулировка расстояний между подграфиками

# 5. Полосовой (ПФ) и заграждающий (ЗФ) фильтры, настроенные на 150 Гц
f1, f2 = 130, 170 # Границы полосы пропускания для ПФ и подавления для ЗФ (около 150 Гц)
w1, w2 = 2 * np.pi * f1, 2 * np.pi * f2 # Угловые частоты границ полосы
bw = w2 - w1 # Ширина полосы пропускания (разница угловых частот)
w0 = np.sqrt(w1 * w2) # Центральная угловая частота полосы (геометрическое среднее)
H_bp = (bw * s) / ((s + w1) * (s + w2)) # Передаточная функция ПФ по формуле 36
H_bs = (s**2 + w0**2) / (s**2 + bw * s + w0**2) # Передаточная функция ЗФ по формуле 37
x_filtered_bp = signal.lfilter([0, bw, 0], [1, bw, w0**2], x) # Применяем ПФ во временной области
x_filtered_bs = signal.lfilter([1, 0, w0**2], [1, bw, w0**2], x) # Применяем ЗФ во временной области
fft_filtered_bp = np.fft.fft(x_filtered_bp) # Спектр после ПФ
fft_filtered_bs = np.fft.fft(x_filtered_bs) # Спектр после ЗФ

plt.figure(figsize=(12, 8)) # Фигура для двух подграфиков
plt.subplot(2, 1, 1) # Первый подграфик (ПФ)
plt.plot(freq[:len(freq)//2], fft_magnitude[:len(freq)//2], 'b-', label='Исходный спектр') # Исходный спектр
plt.plot(freq[:len(freq)//2], np.abs(fft_filtered_bp)[:len(freq)//2], 'r-', label='ПФ (150 Гц)') # Спектр после ПФ
plt.plot(freq[:len(freq)//2], np.abs(H_bp)[:len(freq)//2], 'g--', label='АЧХ ПФ') # АЧХ ПФ
plt.title('Полосовой фильтр (ПФ)') # Заголовок
plt.xlabel('Частота (Гц)') # Подпись оси X
plt.ylabel('Амплитуда') # Подпись оси Y
plt.legend() # Легенда
plt.grid(True) # Сетка

plt.subplot(2, 1, 2) # Второй подграфик (ЗФ)
plt.plot(freq[:len(freq)//2], fft_magnitude[:len(freq)//2], 'b-', label='Исходный спектр') # Исходный спектр
plt.plot(freq[:len(freq)//2], np.abs(fft_filtered_bs)[:len(freq)//2], 'r-', label='ЗФ (150 Гц)') # Спектр после ЗФ
plt.plot(freq[:len(freq)//2], np.abs(H_bs)[:len(freq)//2], 'g--', label='АЧХ ЗФ') # АЧХ ЗФ
plt.title('Заграждающий фильтр (ЗФ)') # Заголовок
plt.xlabel('Частота (Гц)') # Подпись оси X
plt.ylabel('Амплитуда') # Подпись оси Y
plt.legend() # Легенда
plt.grid(True) # Сетка
plt.tight_layout() # Регулировка расстояний

# 6. ФНЧ Баттерворта 4-го и 5-го порядка с автоматическим определением полюсов
def butterworth_lp(n, wc):
    """Функция для вычисления коэффициентов ФНЧ Баттерворта порядка n с частотой среза wc"""
    poles = [np.exp(1j * np.pi * (2*k + n + 1) / (2*n)) for k in range(n)] # Вычисляем полюса по формуле 28
    poles = [p * wc for p in poles if p.real < 0] # Оставляем только полюса в левой полуплоскости (физически реализуемые)
    num = wc**n # Числитель передаточной функции (wc^n)
    den = np.poly(poles) # Знаменатель как полином от полюсов
    return num, den # Возвращаем коэффициенты числителя и знаменателя

wc = 2 * np.pi * 100 # Угловая частота среза (100 Гц) для фильтров 4-го и 5-го порядка
num_4, den_4 = butterworth_lp(4, wc) # Получаем коэффициенты для ФНЧ 4-го порядка
num_5, den_5 = butterworth_lp(5, wc) # Получаем коэффициенты для ФНЧ 5-го порядка
x_filtered_lp4 = signal.lfilter([num_4], den_4, x) # Применяем ФНЧ 4-го порядка
x_filtered_lp5 = signal.lfilter([num_5], den_5, x) # Применяем ФНЧ 5-го порядка
fft_filtered_lp5 = np.fft.fft(x_filtered_lp5) # Вычисляем спектр для ФНЧ 5-го порядка

plt.figure(figsize=(12, 4)) # Фигура для графика
plt.plot(freq[:len(freq)//2], fft_magnitude[:len(freq)//2], 'b-', label='Исходный спектр') # Исходный спектр
plt.plot(freq[:len(freq)//2], np.abs(fft_filtered_lp5)[:len(freq)//2], 'r-', label='ФНЧ 5-го порядка') # Спектр после ФНЧ 5-го порядка
plt.title('Спектр с ФНЧ Баттерворта 5-го порядка') # Заголовок
plt.xlabel('Частота (Гц)') # Подпись оси X
plt.ylabel('Амплитуда') # Подпись оси Y
plt.legend() # Легенда
plt.grid(True) # Сетка

# 7. Сравнение ФНЧ 2-го и 5-го порядка
plt.figure(figsize=(12, 4)) # Фигура для сравнения
plt.plot(freq[:len(freq)//2], np.abs(fft_filtered_lp)[:len(freq)//2], 'b-', label='ФНЧ 2-го порядка') # Спектр ФНЧ 2-го порядка
plt.plot(freq[:len(freq)//2], np.abs(fft_filtered_lp5)[:len(freq)//2], 'r-', label='ФНЧ 5-го порядка') # Спектр ФНЧ 5-го порядка
plt.title('Сравнение ФНЧ 2-го и 5-го порядка') # Заголовок
plt.xlabel('Частота (Гц)') # Подпись оси X
plt.ylabel('Амплитуда') # Подпись оси Y
plt.legend() # Легенда
plt.grid(True) # Сетка
print("ФНЧ 5-го порядка имеет более крутой спад и лучше подавляет высокие частоты, чем ФНЧ 2-го порядка.") # Вывод пояснения в консоль

# 8. Сравнение с встроенным фильтром Баттерворта из scipy.signal
b, a = signal.butter(5, 100, 'low', fs=fs, output='ba') # Создаём ФНЧ 5-го порядка с частотой среза 100 Гц через scipy
x_filtered_scipy = signal.lfilter(b, a, x) # Применяем встроенный фильтр к сигналу
fft_filtered_scipy = np.fft.fft(x_filtered_scipy) # Вычисляем спектр отфильтрованного сигнала

plt.figure(figsize=(12, 4)) # Фигура для сравнения
plt.plot(freq[:len(freq)//2], np.abs(fft_filtered_lp5)[:len(freq)//2], 'b-', label='Мой ФНЧ 5-го порядка') # Моя реализация
plt.plot(freq[:len(freq)//2], np.abs(fft_filtered_scipy)[:len(freq)//2], 'r--', label='scipy ФНЧ 5-го порядка') # Реализация scipy
plt.title('Сравнение моей реализации и scipy.signal') # Заголовок
plt.xlabel('Частота (Гц)') # Подпись оси X
plt.ylabel('Амплитуда') # Подпись оси Y
plt.legend() # Легенда
plt.grid(True) # Сетка

# 9. Добавление шума и фильтрация зашумленного сигнала
noise = np.random.normal(0, 0.5, x.shape) # Генерируем белый шум с нормальным распределением (дисперсия 0.5)
x_noisy = x + noise # Добавляем шум к исходному сигналу
x_noisy_filtered = signal.lfilter([num_5], den_5, x_noisy) # Применяем ФНЧ 5-го порядка к зашумленному сигналу
fft_noisy = np.fft.fft(x_noisy) # Вычисляем спектр зашумленного сигнала
fft_noisy_filtered = np.fft.fft(x_noisy_filtered) # Вычисляем спектр отфильтрованного зашумленного сигнала

plt.figure(figsize=(12, 8)) # Фигура для двух подграфиков
plt.subplot(2, 1, 1) # Первый подграфик
plt.plot(t, x_noisy, 'b-', label='Зашумленный сигнал') # Зашумленный сигнал во временной области
plt.plot(t, x_noisy_filtered, 'r-', label='Отфильтрованный зашумленный сигнал') # Отфильтрованный сигнал
plt.title('Зашумленный и отфильтрованный сигнал') # Заголовок
plt.xlabel('Время (с)') # Подпись оси X
plt.ylabel('Амплитуда') # Подпись оси Y
plt.legend() # Легенда
plt.grid(True) # Сетка

plt.subplot(2, 1, 2) # Второй подграфик
plt.plot(freq[:len(freq)//2], np.abs(fft_noisy)[:len(freq)//2], 'b-', label='Спектр зашумленного сигнала') # Спектр зашумленного сигнала
plt.plot(freq[:len(freq)//2], np.abs(fft_noisy_filtered)[:len(freq)//2], 'r-', label='Спектр отфильтрованного') # Спектр после фильтрации
plt.title('Спектр зашумленного сигнала с ФНЧ 5-го порядка') # Заголовок
plt.xlabel('Частота (Гц)') # Подпись оси X
plt.ylabel('Амплитуда') # Подпись оси Y
plt.legend() # Легенда
plt.grid(True) # Сетка
plt.tight_layout() # Регулировка расстояний

# 10. ФНЧ Чебышева 1-го рода 5-го порядка
def chebyshev_lp(n, wc, ripple):
    """Функция для создания ФНЧ Чебышева 1-го рода порядка n с заданной пульсацией (ripple в дБ)"""
    b, a = signal.cheby1(n, ripple, wc/(2*np.pi), 'low', fs=fs, output='ba') # Используем scipy для вычисления коэффициентов
    return b, a # Возвращаем коэффициенты числителя (b) и знаменателя (a)

b_cheb, a_cheb = chebyshev_lp(5, 100, 1) # Создаём ФНЧ Чебышева 5-го порядка с частотой среза 100 Гц и пульсацией 1 дБ
x_filtered_cheb = signal.lfilter(b_cheb, a_cheb, x) # Применяем фильтр к исходному сигналу
fft_filtered_cheb = np.fft.fft(x_filtered_cheb) # Вычисляем спектр отфильтрованного сигнала

plt.figure(figsize=(12, 4)) # Фигура для графика
plt.plot(freq[:len(freq)//2], fft_magnitude[:len(freq)//2], 'b-', label='Исходный спектр') # Исходный спектр
plt.plot(freq[:len(freq)//2], np.abs(fft_filtered_cheb)[:len(freq)//2], 'r-', label='ФНЧ Чебышева 5-го порядка') # Спектр после Чебышева
plt.title('Спектр с ФНЧ Чебышева 1-го рода 5-го порядка') # Заголовок
plt.xlabel('Частота (Гц)') # Подпись оси X
plt.ylabel('Амплитуда') # Подпись оси Y
plt.legend() # Легенда
plt.grid(True) # Сетка

plt.show() # Отображаем все графики
